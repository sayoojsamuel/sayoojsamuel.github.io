<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Cool New Hexo</title>
      <link href="/2018/10/28/Site-Updated/"/>
      <url>/2018/10/28/Site-Updated/</url>
      <content type="html"><![CDATA[<p>Wow, This looks cool! </p><p>Let me tell you a fact, that Hexo is totally cool! To start with, I’m writing my blog with the <strong>Hexo Admin</strong> plugin. This blog is build with cool new features, far more than I can list out here. </p><p>Guys, this will be the beginning of series of blog posts to handle Hexo Blogging. Not much to say right now. Till next time, Adios!</p>]]></content>
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>tile-mate</title>
      <link href="/2018/10/26/tile-mate/"/>
      <url>/2018/10/26/tile-mate/</url>
      <content type="html"><![CDATA[<p>Writeup from Bsides CTF’18</p><h1 id="Bsides-CTF-2018-Tile-Mate"><a href="#Bsides-CTF-2018-Tile-Mate" class="headerlink" title="Bsides CTF 2018: Tile Mate"></a>Bsides CTF 2018: Tile Mate</h1><p><strong>Category:</strong> Crypto<br><strong>Challenge Points:</strong> 100<br><strong>Solves:</strong> 35<br><strong>Description:</strong></p><pre><code class="bash">David and Toni rides scooter. Everyone knows except them!</code></pre><p><strong>Attachments:</strong> tile_mate.tar.xz</p><p>This is an easy <code>XOR</code> challenge, with a custom plaintext substitution before the actual <code>XOR</code> process.<br>Again, the attachment contains two files</p><ol><li>encrypt.py</li><li>ci.pher.text</li></ol><pre><code class="python">from itertools import cycle as scooterfrom secret import FLAG, KEYfrom hashlib import sha384assert FLAG.islower()assert len(KEY) == 10def drive(Helmet, Petrol):    return &#39;&#39;.join(chr(ord(David)^ord(Toni)) for David,Toni in zip(Helmet,scooter(Petrol)))f = lambda x: sha384(x).digest()[(ord(x)+7)%48]encrypted = drive(map(f,FLAG),KEY.decode(&#39;hex&#39;)).encode(&#39;hex&#39;)open(&#39;ci.pher.text&#39;,&#39;wb&#39;).write(encrypted)</code></pre><p>Hmm, it is pretty obvious <code>drive()</code> is the <strong>Repeated Key <code>XOR</code></strong> function, although the function looks cool! (Atleast the ‘Helmet,scooter(Petrol)’ part :p)..<br><code>f</code> being another function which returns the <code>x+7</code>th index character from the sha384 hash of <code>x</code>.<br>The ciphertext is simply the XOR(f(pt),key).</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><pre><code class="python">assert FLAG.islower()assert len(KEY) == 10</code></pre><p>This suggests that the <strong>flag</strong> is composed of lowercase characters (digits and punctuation included) and the <strong>key</strong> length is 5 bytes (hex 10). </p><h4 id="Key-Recovery"><a href="#Key-Recovery" class="headerlink" title="Key Recovery"></a>Key Recovery</h4><p>Since the flag format is <code>flag{</code>, we can recover the <strong>key</strong> by XORing f(“<code>flag{</code>“) with <code>ciphertext</code>.</p><pre><code class="python">hashed_flag = &#39;&#39;.join(map(f,&quot;flag{&quot;))key = xor(hashed_flag,ct)hashed_pt = xor(ct,key)</code></pre><p>Now this <code>hashed_pt</code> is nothing but the hash of the <code>flag</code>.</p><h4 id="Getting-to-the-Flag"><a href="#Getting-to-the-Flag" class="headerlink" title="Getting to the Flag"></a>Getting to the Flag</h4><pre><code>f = lambda x: sha384(x).digest()[(ord(x)+7)%48]</code></pre><p>This custom hash is not reversible, but we can still create a map with all possible characters, cause that’s just 90 possibilities ( Remember the lowercase?)</p><pre><code class="python">chars = string.ascii_lowercase+string.digits+string.punctuationtable = dict(zip(map(f,chars),chars))flag=&quot;&quot;for i in hashed_pt: flag+=table[i]print flag</code></pre><p>The <code>table</code> contains the dict of hash, and character as key, value pair.<br>For characters in <code>hashed_pt</code>, we find the preimage of the hash from the table. And you hold the flag for the challenge, TADA!!!</p><h2 id="Complete-Script"><a href="#Complete-Script" class="headerlink" title="Complete Script"></a>Complete Script</h2><pre><code class="python">from hashlib import sha384from itertools import cycleimport stringdef xor(msg,key):    return &#39;&#39;.join(chr(ord(i)^ord(j)) for i,j in zip(msg,cycle(key)))f = lambda x: sha384(x).digest()[(ord(x)+7)%48]ct = open(&#39;ci.pher.text&#39;,&#39;rb&#39;).read().decode(&#39;hex&#39;)hashed_flag = &#39;&#39;.join(map(f,&quot;flag{&quot;))key = xor(hashed_flag,ct)hashed_pt = xor(ct,key)chars = string.ascii_lowercase+string.digits+string.punctuationtable = dict(zip(map(f,chars),chars))flag=&quot;&quot;for i in hashed_pt: flag+=table[i]print flag</code></pre><h2 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h2><p><strong>flag{cr1b_dr4g_w1th_u1tr4_c00l_sc00ter!}</strong></p><h3 id="Author’s-Note"><a href="#Author’s-Note" class="headerlink" title="Author’s Note"></a>Author’s Note</h3><p>Okay, this is the second challenge I authored for BSides CTF’18 being organised at Delhi, the first one being <a href="https://sayoojsamuel.github.io/2018/10/26/pyQueue/">pyQueue</a>.</p><h2 id="4-Line-exploit"><a href="#4-Line-exploit" class="headerlink" title="4 Line exploit"></a>4 Line exploit</h2><p>Just a show-off, </p><pre><code class="python">from hashlib import sha384;from itertools import cycle;import stringxor,f,ct,chars=lambda (msg,key): &#39;&#39;.join(chr(ord(i)^ord(j)) for i,j in zip(msg,cycle(key))),lambda x: sha384(x).digest()[(ord(x)+7)%48],open(&#39;ci.pher.text&#39;,&#39;rb&#39;).read().decode(&#39;hex&#39;),string.ascii_lowercase+string.digits+string.punctuationhashed_pt,flag,table=xor((ct,xor((&#39;&#39;.join(map(f,&quot;flag{&quot;)),ct)))),&quot;&quot;,dict(zip(map(f,chars),chars))for i in hashed_pt: flag+=table[i];print flag</code></pre>]]></content>
      
      <categories>
          
          <category> Writeups </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XOR, Python, Custom, Hash, Delhi, , Bsides, CTF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>pyQueue</title>
      <link href="/2018/10/26/pyQueue/"/>
      <url>/2018/10/26/pyQueue/</url>
      <content type="html"><![CDATA[<p>Writeup from Bsides CTF’18</p><h1 id="Bsides-CTF-2018-pyQueue"><a href="#Bsides-CTF-2018-pyQueue" class="headerlink" title="Bsides CTF 2018: pyQueue"></a>Bsides CTF 2018: pyQueue</h1><p><strong>Category:</strong> Crypto<br><strong>Challenge Points:</strong> 150<br><strong>Solves:</strong> 43<br><strong>Description:</strong></p><pre><code class="bash">Easy Right?</code></pre><p><strong>Attachments:</strong> pyQueue.tar.xz</p><p>The attachment contains two files</p><ol><li>encrypt.py</li><li>ci.pher.text</li></ol><p>Let’s analyse the <code>encrypt.py</code></p><pre><code class="python">key = AES_Key()ct=&quot;&quot;MAC = 0for List in slice(FLAG):    for block in List:        cipher = AES.new(key.shuffle(), AES.MODE_ECB)        ct+= cipher.encrypt(block)        MAC ^= int(ct[-16:].encode(&#39;hex&#39;),16)MAC ^= int(key.shuffle().encode(&#39;hex&#39;),16)open(&quot;ci.pher.text&quot;,&#39;wb&#39;).write(str(MAC) +&quot;:&quot;+ ct.encode(&#39;hex&#39;))</code></pre><p>Well, it’s an AES challenge on first sight. Three points to note, </p><ol><li>Each time an AES instance is created, a new <strong>key</strong> is being used as a resultant of <code>key.shuffle()</code></li><li><strong>MAC</strong> is generated as the <code>XOR</code> of all the <code>ct</code> blocks. At the end, <strong>MAC</strong> is xored with <strong>key</strong> after being shuffled for one last time.<pre><code class="python">MAC ^= int(key.shuffle().encode(&#39;hex&#39;),16)</code></pre></li><li><strong>ci.pher.text</strong> is of the format <em>MAC:CipherText</em> </li></ol><p>A peek into the Key generation, </p><pre><code class="python">class AES_Key:    def __init__(self):        self.key=list(os.urandom(16))    def enqueue(self):        self.key+=get_random_bytes(1)    def dequeue(self):        self.key=self.key[1:]    def size(self):        return len(self.key)    def shuffle(self):        self.dequeue()        self.enqueue()        assert self.size()==AES.block_size        return &quot;&quot;.join(self.key)</code></pre><p>This reveals that <code>shuffle()</code> method just removes the first byte of the 16 byte <strong>key</strong> and appends a random byte at the end. The complete setup was implemented as a Queue :P. This makes it a whole lot easier to bruteforce!</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h4 id="Key-Recovery"><a href="#Key-Recovery" class="headerlink" title="Key Recovery"></a>Key Recovery</h4><p>Now, to recover the <strong>key</strong>, we just have to <code>XOR</code> the <strong>MAC</strong> with all the <code>ct</code> blocks. The resultant is the key.shuffled() value.</p><pre><code class="python"># Calculate keylast_key = int(MAC)for i in ct:    last_key ^= int(i.encode(&#39;hex&#39;), 16)last_key = long_to_bytes(last_key)</code></pre><h4 id="BruteForce"><a href="#BruteForce" class="headerlink" title="BruteForce"></a>BruteForce</h4><p>All you need to do now is to bruteforce over 256 possible character. That is, remove the last byte of <code>assumed key</code> and add the bruteforce character at the beginning. The <strong>key</strong> pair for the <code>plaintext</code> where most of the starting characters are printable is what we are looking for.</p><pre><code class="python">def brute():    key = last_key    pt = &quot;&quot;    for i in range(2,-1,-1):        key = key[:-1]        for ch in range(256):            cipher = AES.new(chr(ch)+key,AES.MODE_ECB)            recover = cipher.decrypt(ct[i])            if(all(c in printable for c in recover[:10])):                pt = recover + pt                key = chr(ch)+key                break    return pt</code></pre><h2 id="Complete-Script"><a href="#Complete-Script" class="headerlink" title="Complete Script"></a>Complete Script</h2><pre><code class="python">from Crypto.Cipher import AESfrom Crypto.Util.number import *from string import printabledef split_by(msg,step):    return [msg[i:i+step] for i in range(0,len(msg),16)]data = open(&quot;ci.pher.text&quot;,&#39;rb&#39;).read()MAC,ct = data.split(&quot;:&quot;)ct = split_by(ct.decode(&#39;hex&#39;),16)# Calculate keylast_key = int(MAC)for i in ct:    last_key ^= int(i.encode(&#39;hex&#39;), 16)last_key = long_to_bytes(last_key)# Brute Joy!!!key = last_keydef brute():    key = last_key    pt = &quot;&quot;    for i in range(2,-1,-1):        key = key[:-1]        for ch in range(256):            cipher = AES.new(chr(ch)+key,AES.MODE_ECB)            recover = cipher.decrypt(ct[i])            if(all(c in printable for c in recover[:10])):                pt = recover + pt                key = chr(ch)+key                break    return ptprint brute()</code></pre><h2 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h2><p><strong>flag{H4il_bUggi3s!_qu3u3_k3y_2_h0t_4_w4rmUp}</strong></p><h3 id="Author’s-Note"><a href="#Author’s-Note" class="headerlink" title="Author’s Note"></a>Author’s Note</h3><p>I authored this challenge for Bsides CTF’18. I know that these kinda bruteforce challenges makes it hard for pro’s to play with, but will be pretty interesting for the beginners. I’m just saying :p<br>Also, check out the writeup of <a href="https://sayoojsamuel.github.io/2018/10/26/tile-mate/">Tile-Mate</a> (Crypto 100) challenge here.</p>]]></content>
      
      <categories>
          
          <category> Writeups </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bruteforce, Python, Queue, AES, ECB, Bsides, CTF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>flatcrypto</title>
      <link href="/2018/09/16/flatcrypto/"/>
      <url>/2018/09/16/flatcrypto/</url>
      <content type="html"><![CDATA[<p>Writeup from CSAW QUALS CTF’18</p><h1 id="CSAW-CTF-QUALS-2018-Flatcrypto"><a href="#CSAW-CTF-QUALS-2018-Flatcrypto" class="headerlink" title="CSAW CTF QUALS 2018: Flatcrypto"></a>CSAW CTF QUALS 2018: Flatcrypto</h1><p><strong>Category:</strong> Crypto<br><strong>Challenge Points:</strong> 100<br><strong>Solves:</strong> 184<br><strong>Description:</strong></p><pre><code>no logos or branding for this bugTake your pick nc crypto.chal.csaw.io 8040 nc crypto.chal.csaw.io 8041 nc crypto.chal.csaw.io 8042 nc crypto.chal.csaw.io 8043flag is not in flag format. flag is PROBLEM_KEY</code></pre><p><strong>Attachments:</strong> serv-distribute.py</p><pre><code class="python">import zlibimport osfrom Crypto.Cipher import AESfrom Crypto.Util import CounterENCRYPT_KEY = bytes.fromhex(&#39;0000000000000000000000000000000000000000000000000000000000000000&#39;)# Determine this key.# Character set: lowercase letters and underscorePROBLEM_KEY = &#39;not_the_flag&#39;def encrypt(data, ctr):    return AES.new(ENCRYPT_KEY, AES.MODE_CTR, counter=ctr).encrypt(zlib.compress(data))    while True:        f = input(&quot;Encrypting service\n&quot;)        if len(f) &lt; 20:            continue        enc = encrypt(bytes((PROBLEM_KEY + f).encode(&#39;utf-8&#39;)), Counter.new(64, prefix=os.urandom(8)))        print(&quot;%s%s&quot; %(enc, chr(len(enc))))</code></pre><p>Again, it’s another sipmple challenge based on AES_CTR.  For all those noobies, note that AES Counter mode does not have <strong><code>Padding</code></strong>.  And this challenge is specifically based on that. If we have a close look, it is the PROBLEM_KEY which we need to figure out. Now see that,</p><pre><code class="python">enc = encrypt(bytes((PROBLEM_KEY + f).encode(&#39;utf-8&#39;)),    |Counter.new(64, prefix=os.urandom(8)))</code></pre><p>is where we target out exploit.  Our input <code>f</code> is appended to the PROBLEM_KEY, compressed and then encrypted without padding.   This zlib compression is a huge vuln, and we forge a custom input such that the plaintext is compressed before encryption. Thus, it results in reduced length of the ciphertext.</p><p>It is mentioned that the character set is lowercase ascii and underscore.<br>I have created a bruteforce script, in which, the brute starts with character ‘a’ till ‘z’ multiplied 20 times.<br>The length of the ciphertext decreases when the <strong>brute_char</strong> matches with the <strong>last byte</strong> of the PRODUCT_KEY. For the second last byte, we repeat the <strong>brute_char+lastbyte</strong> 20 times. Similarly the third last byte, which follows as<br><strong>brute_char+secondlast+lastbyte</strong> 20 times.</p><p>This will eventually give us the flag, which is not in the flag format.</p><h2 id="Complete-Script"><a href="#Complete-Script" class="headerlink" title="Complete Script"></a>Complete Script</h2><pre><code class="python">from pwn import *context.log_level=&quot;error&quot;import stringchars = string.ascii_lowercase + &quot;_&quot;flag = &quot;&quot;    for j in range(30):    print &quot;flag:&quot;,flag    for i in chars:        io = remote(&quot;crypto.chal.csaw.io&quot;,8040)        print io.recv()        io.sendline((i+flag)*20)        print (i+flag)        out = io.recvline()        l = ord(out[-2])        print &quot;len=&quot;,l, i        if l&lt;35:                  #&lt;== You have to edit this manually            print i            flag=i+flag            break        io.close()</code></pre><h2 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h2><p><strong>crime_doesnt_have_a_logo</strong></p><h3 id="Plaid-CTF-Compression"><a href="#Plaid-CTF-Compression" class="headerlink" title="Plaid CTF Compression"></a>Plaid CTF Compression</h3><p>A note to all the readers, that this challenge was the exact copy of the 2013 Plaid CTF challenge - Compression.  Dosen’t know why they have to give the exact same question.  Follow the writeup for the challenge for detailed explanation.</p>]]></content>
      
      <categories>
          
          <category> Writeups </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zlib, compression, CTF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>babycrypto</title>
      <link href="/2018/09/16/babycrypto/"/>
      <url>/2018/09/16/babycrypto/</url>
      <content type="html"><![CDATA[<p>Writeup from CSAW QUALS CTF’18</p><h1 id="CSAW-CTF-QUALS-2018-Babycrypto"><a href="#CSAW-CTF-QUALS-2018-Babycrypto" class="headerlink" title="CSAW CTF QUALS 2018: Babycrypto"></a>CSAW CTF QUALS 2018: Babycrypto</h1><p><strong>Category:</strong> Crypto<br><strong>Challenge Points:</strong> 50<br><strong>Solves:</strong> 295<br><strong>Description:</strong></p><pre><code>yeeeeeeeeeeeeeeeeeeeeeeeeeeeeeetsingle yeet yeeted with single yeet == 0yeeetwhat is yeet?yeet is yeet</code></pre><p><strong>Attachments:</strong> ciphertext.txt<br><code>PRO TIP</code>:Tell you what, the smallest crypto will always be XOR in CSAW!  And <code>a XOR a == 0</code> ==&gt;</p><pre><code>|single yeet yeeted with single yeet == 0</code></pre><p>And that’s the hint! to suggest it is a XOR challenge. So, we start with the attachment file, which includes a <code>base64</code> encoded ciphertext.<br>Perform a single byte xor, and you’ll find the flag in character 255.</p><pre><code class="bash">Leon is a programmer who aspires to create programs that help people do less. He wants to put automation first, and scalability alongside. He dreams of a world where the endless and the infinite become realities to mankind, and where the true value of life is preserved.flag{diffie-hellman-g0ph3rzraOY1Jal4cHaFY9SWRyAQ6aH}</code></pre><h2 id="Complete-Script"><a href="#Complete-Script" class="headerlink" title="Complete Script"></a>Complete Script</h2><pre><code class="python">import stringdef xor(a,b):    return chr(ord(i)^ord(j) for i,j in zip(a,b))ct = open(&#39;ciphertext.txt&#39;,&#39;rb&#39;).read().decode(&#39;base64&#39;)for i in range(256):    pt = xor(ct,chr(i)*len(ct))    if all(c in string.printable for c in pt): print pt</code></pre><h2 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h2><p><strong>flag{diffie-hellman-g0ph3rzraOY1Jal4cHaFY9SWRyAQ6aH}</strong></p>]]></content>
      
      <categories>
          
          <category> Writeups </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xor, yeet, , CTF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Marty0ska1</title>
      <link href="/2018/09/14/marty0ska1/"/>
      <url>/2018/09/14/marty0ska1/</url>
      <content type="html"><![CDATA[<p>Writeup from SEC-T CTF’18</p><h1 id="SEC-T-CTF-2018-Marty0ska1"><a href="#SEC-T-CTF-2018-Marty0ska1" class="headerlink" title="SEC-T CTF 2018: Marty0ska1"></a>SEC-T CTF 2018: Marty0ska1</h1><p><strong>Category:</strong> Crypto<br><strong>Challenge Points:</strong> 51<br><strong>Solves:</strong> 60+</p><p><strong>Service:</strong> nc crypto.sect.ctf.rocks 2222</p><p>Really bad they took down the website and services soon after the CTF, I coudn’t complete my write up. So as you read, don’t expect the flag, though the method remains the same.</p><pre><code class="bash">nc crypto.sect.ctf.rocks 2222</code></pre><p>As you are connected to the service, you are given three numbers: <code>p</code>, <code>g</code>, and <code>g^x</code>. They demand <code>x</code>.</p><h3 id="Discrete-Logarithmic-Problem"><a href="#Discrete-Logarithmic-Problem" class="headerlink" title="Discrete Logarithmic Problem"></a>Discrete Logarithmic Problem</h3><p>A stright DLP challenge. Things to notice, <code>g</code>=2, and <code>p</code> is <em>factorizable</em>.  Tada!! it is Pohlig-Hellman. Use a sage script to solve the challenge.<br>Let y=g^x</p><pre><code class="sage">R = IntegerModRing(p)x = discrete_log(R(y), R(g))print x</code></pre><p>This will give the flag in less than two seconds. And that it.Submit x, to get the flag.</p><h2 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h2><p>**SECT{Ru$$ian_D0LLZ_h0lDs_TH3_S3cR3T}</p><h3 id="Further-Reading"><a href="#Further-Reading" class="headerlink" title="Further Reading"></a>Further Reading</h3><p>Tum CTF 2016 <a href="http://mslc.ctf.su/wp/tum-ctf-2016-tacos-crypto-300/" target="_blank" rel="noopener">tacos</a></p>]]></content>
      
      <categories>
          
          <category> Writeups </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto, DLP, Pohlig-Hellman Algorithm, CTF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Encoding</title>
      <link href="/2018/09/12/encoding/"/>
      <url>/2018/09/12/encoding/</url>
      <content type="html"><![CDATA[<p>The basics of Encoding, a Beginner’s guide</p><h1 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a>Encoding</h1><h2 id="What-is-Encoding"><a href="#What-is-Encoding" class="headerlink" title="What is Encoding?"></a>What is Encoding?</h2><p>If we start explain it to a 10 year old, the definition would go like, “Encoding is the process of changing data representation”.<br>Rather, may be we should check this out :  <em>In computer technology, encoding is the process of applying a specific code, such as letters, symbols and numbers, to data for conversion into an equivalent cipher.</em><br>The most common example would be changing “abc” to “ABC”, the lower-to-upper encoding.</p><p>That was pretty basic! We also have a standard for converting characters.<br>American Standard Code for Information Interchange (ASCII) was introduced just for that.<br>Under ASCII, each character is given a unique decimal equivalent. That is, the character ‘A’ is given code 65, ‘B’ 66 and so on.<br>You can see the complete reference by typing the following in your linux terminal. </p><pre><code class="bash">$ man ascii</code></pre><p>Now, if you have done that, it’s now clear that ASCII contains printable and nonprintable characters that represent uppercase and lowercase letters, symbols, punctuation marks and numbers.<br>In <code>man ascii</code>, you must have noticed that there was a seperate tab called oct and hex. These are different number system, which we will be covering below.<br>So a string, “Hello” can be converted to ASCII as “72 101 108 108 111”. This is how computers process information.</p><h3 id="Number-System"><a href="#Number-System" class="headerlink" title="Number System"></a>Number System</h3><ul><li>Binary</li><li>Octal</li><li>Decimal</li><li>Hexadecimal</li></ul><p>Decimal is the number system used around the world. But if you peep into Mathematical Computing, we have many number systems.<br>The most prevalent is <strong>Binary</strong>, which uses just 1’s and 0’s to represent data [Thus it is a base 2 number system]. Next we have <strong>Octal</strong> number system with base 8. Here, we use 8 digits to represent data, from 0,1,2 to 7. We also have hexadecimal, another commonly used system. Hexadecimal in fact means a base of 16. Since we only have 10 digits, we also use characters from A to F. So hex characters include 1,2,..,9,A,B,C,D,E and F, making a total of 16 digits. It is possible to convert data from<br>one system to another, but that is beyond the scope of this tutorial.</p><h2 id="Hex-Encoding"><a href="#Hex-Encoding" class="headerlink" title="Hex Encoding"></a>Hex Encoding</h2><p>Hex encoding is the process of changing data into hexadecimal representation. Having said that, Hexadecimal numerals are widely used by computer system designers and programmers, as they provide a more human-friendly representation of binary values. You can also try converting decimals and Strings to hex.<br>Each hexadecimal character can be expanded into binary digits (A nibble). And it implies that a byte of data can be represented using two hex chars. Isn’t that cool?</p><p>!!!Note<br>In order to differentiate between the representations, we have different prefixes added to the data.<br><strong>\x</strong> or <strong>0x</strong> is the generally accepted prefix added to hexadecimal string.<br>!!!</p><h3 id="A-quick-Example"><a href="#A-quick-Example" class="headerlink" title="A quick Example:"></a>A quick Example:</h3><p>0000 of binary will convert to ‘0’ of hex. Similarly, ‘f’ of hex will be 1111 of binary.<br>Taking a byte at a time –&gt;<br><strong>0x00</strong> is <strong>0b00000000</strong>, <strong>0x01</strong> is <strong>0b00000001</strong>, and so and so forth till <strong>0x0f</strong> represents <strong>0b00001111</strong> (The Decimal equivalent is 15). When we move further, <strong>0x10</strong> is <strong>0b00010000</strong> (Decimal 16) till <strong>0xff</strong> which is <strong>0b11111111</strong> (Decimal 255).</p><h3 id="The-Encoding-part"><a href="#The-Encoding-part" class="headerlink" title="The Encoding part"></a>The Encoding part</h3><p>Recollect that each character is assigned a decimal equivalent in ASCII [from 0 to 255].<br>If we try to map it together, it turns out that each of the decimal equivalent can then be converted into hex.<br>That’s it! The character ‘<strong>A</strong>‘ has decimal value of <strong>65</strong>, which converts to <strong>0x41</strong> in hex.</p><p>So next time we say <strong>0x68656c6c6f</strong>, be sure to convert it into <strong>ASCII</strong>. If you are too lazy (its common among hackers,) it’s just “Hello” !</p><h2 id="Base64-Encoding"><a href="#Base64-Encoding" class="headerlink" title="Base64 Encoding"></a>Base64 Encoding</h2><p>As mentioned, Hex had only 16 characters. But this one is still awesome. Meet the Base64, with 64 characters. Base64 encoding takes three bytes, each consisting of 8 bits. The following is the character set for Base64  -</p><pre><code>1. [a-z]  -  26 characters2. [A-Z]  -  26 characters3. [0-9]  -  10 characters4. [+]    -  1 character5. [/]    -  1 character</code></pre><p>Now that if you count, it will add up to 64.  It also have ‘=’ character, which is solely used for padding purposes.<br>This character set includes uppercase and lowercase alphabets, digits, ‘+’ and ‘/‘. </p><h3 id="Encoding-1"><a href="#Encoding-1" class="headerlink" title="Encoding"></a>Encoding</h3><p>The process is really simple. Write down the binary of the message, taking groups of 6 in one block. Now compare each block with the binary or decimal value with the corresponding character in the Base64 Chart. Join the characters, and that it. You’re done! </p><h4 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h4><p>Always remember, your Base64 string length should be a multiple of 3. If not, you must add ‘=’ character at the end untill it’s a multiple. Padding is necessarity required for Base64 and it might save you from Padding errors.<br>Pro Tip: And if you happen to see ‘=’ at the end of the string, don’t hesitate, try a Base64 decode!</p><h2 id="Hands-On"><a href="#Hands-On" class="headerlink" title="Hands-On"></a>Hands-On</h2><p>So where do you start?  We’ll share you an ‘WOW, THAT’s AWESOME!’ tip.  Forget all that boring pen paper calculation you have to do!  If you have a python shell, just simply type:</p><pre><code class="python">print &quot;your-string-here&quot;.encode(&#39;hex&#39;)</code></pre><p>to print the Hex encoded string. To decode a hex string, just change it to</p><pre><code class="python">print &quot;some-hex-string&quot;.decode(&#39;hex&#39;)</code></pre><p>Similarly, you can do Base64 encoding with <code>.encode(&#39;base64&#39;)</code></p><p>It’s also fine if you’re comfortable using online tools for these. At times, even they come handly!</p>]]></content>
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Encoding, CTF, Hex, Base64, Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Chop Suey</title>
      <link href="/2018/09/09/chopsuey/"/>
      <url>/2018/09/09/chopsuey/</url>
      <content type="html"><![CDATA[<p>Writeup from noxCTF’18</p><h1 id="noxCTF-2018-Chop-Suey"><a href="#noxCTF-2018-Chop-Suey" class="headerlink" title="noxCTF 2018: Chop-Suey"></a>noxCTF 2018: Chop-Suey</h1><p><strong>Category:</strong> Crypto<br><strong>Challenge Points:</strong> 118<br><strong>Solves:</strong> 235<br><strong>Description:</strong> </p><pre><code class="bash">Today I ate in a Chinese restaurant and got myself a fortune cookie. These things usually contain a note with a nice sentence or phrase, but mine had numbers in it instead! Can you help me find the meaning of the numbers?p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852</code></pre><p>So if you have learned Chinese Remainder Theorem, you would definitely have known this optimisation technique for RSA.<br>It states:<br><code>dp = d (mod p-1)</code><br><code>dq = d (mod q-1)</code><br>This technique is more faster than the Textbook RSA and with out <strong>p</strong> and <strong>q</strong>, you’d be having a really tough time. Just take a glimpse into what <a href="https://en.wikipedia.org/wiki/RSA_\(cryptosystem\" target="_blank" rel="noopener">Wiki</a>#Using_the_Chinese_remainder_algorithm) has to say.<br>But for the funny part, they have already provided us with p and q values! We can easily recompute <code>qinv</code>, to get the flag.</p><h3 id="To-construct-qinv"><a href="#To-construct-qinv" class="headerlink" title="To construct qinv,"></a>To construct <strong>qinv</strong>,</h3><pre><code class="python">qinv = modinv(q, p)m2 = pow(c, dq, q)m1 = pow(c, dp, p)h = (qinv * (m1 - m2)) % pm = m2 + h * q</code></pre><h3 id="The-complete-script"><a href="#The-complete-script" class="headerlink" title="The complete script:"></a>The complete script:</h3><pre><code class="python">from gmpy2 import *p=8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229q=12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469dp=6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929dq=783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041c=24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852def egcd(a, b):    if a == 0:        return (b, 0, 1)    else:        g, y, x = egcd(b % a, a)        return (g, x - (b // a) * y, y)def modinv(a, m):    g, x, y = egcd(a, m)    if g != 1:        raise Exception(&#39;modular inverse does not exist&#39;)    else:        return x % mqinv = modinv(q, p)m2 = pow(c, dq, q)m1 = pow(c, dp, p)h = (qinv * (m1 - m2)) % pm = m2 + h * qprint(m)txt = hex(m)[2:]print &#39;&#39;.join([chr(int(&#39;&#39;.join(c), 16)) for c in zip(txt[0::2],txt[1::2])])</code></pre><h2 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h2><p><strong>noxCTF{W31c0m3_70_Ch1n470wn}</strong></p>]]></content>
      
      <categories>
          
          <category> Writeups </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto, RSA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Principium</title>
      <link href="/2018/08/26/Principium/"/>
      <url>/2018/08/26/Principium/</url>
      <content type="html"><![CDATA[<p>Welcome to my first Post!</p><h2 id="This-is-totally-crazy"><a href="#This-is-totally-crazy" class="headerlink" title="This is totally crazy"></a>This is totally crazy</h2><pre><code>&#39;&#39;&#39;bash    sudo kill -me&#39;&#39;&#39;</code></pre><h2 id="OK-See-the-wonders-at"><a href="#OK-See-the-wonders-at" class="headerlink" title="OK - See the wonders at"></a>OK - See the wonders at</h2><p>See more at: [Sayooj Samuel] (sayoojsamuel.github.io)</p>]]></content>
      
      
    </entry>
    
  
  
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<h1 id="About-OneDark"><a href="#About-OneDark" class="headerlink" title="About OneDark"></a>About OneDark</h1><p>One Dark is my Personal Blog, a platform to showcase my interests and express my brain out.<br>Myself Sayooj Samuel, a 2nd year Computer Science Undergraduate, at Amrita Unversity, Amritapuri.  My brain is totally devoted to my wierd ideas.  </p><p>My Blog will be covering concepts and writeups about Cryptography challenges from CTF’s, that one being my favorite since the idea of Cyber Security crawled my thoughts.</p>]]></content>
    </entry>
    
    <entry>
      <title>links</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      <content type="html"><![CDATA[<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2>]]></content>
    </entry>
    
  
</search>
